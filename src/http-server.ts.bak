#!/usr/bin/env node

import express from 'express';
import cors from 'cors';
import { AutoHotkeyMcpServer } from './server.js';
import logger from './logger.js';

/**
 * HTTP wrapper for the AutoHotkey MCP Server
 * Provides REST API endpoints for ChatGPT integration
 */
class AutoHotkeyHttpServer {
  private app: express.Application;
  private mcpServer: AutoHotkeyMcpServer;
  private port: number;

  constructor(port: number = 3000) {
    this.app = express();
    this.port = port;
    this.mcpServer = new AutoHotkeyMcpServer();
    this.setupMiddleware();
    this.setupRoutes();
  }

  private setupMiddleware(): void {
    this.app.use(cors());
    this.app.use(express.json({ limit: '10mb' }));
    this.app.use(express.urlencoded({ extended: true }));
  }

  private setupRoutes(): void {
    // Health check
    this.app.get('/health', (req, res) => {
      res.json({ status: 'ok', server: 'AutoHotkey MCP Server' });
    });

    // List available tools
    this.app.get('/tools', async (req, res) => {
      try {
        // Directly access tool definitions from the server
        const tools = {
          tools: [
            // This would need to be implemented properly in your server
            // For now, return a basic structure
            { name: 'AHK_Diagnostics', description: 'AutoHotkey diagnostics tool' },
            { name: 'AHK_Analyze', description: 'AutoHotkey analysis tool' },
            { name: 'AHK_Prompts', description: 'AutoHotkey prompts tool' }
          ]
        };
        res.json(tools);
      } catch (error) {
        logger.error('Error listing tools:', error);
        res.status(500).json({ error: 'Failed to list tools' });
      }
    });

    // Execute tool
    this.app.post('/tools/:toolName', async (req, res) => {
      try {
        const { toolName } = req.params;
        const args = req.body;

        const result = await this.mcpServer.getServer().request(
          {
            method: 'tools/call',
            params: {
              name: toolName,
              arguments: args
            }
          },
          {}
        );

        res.json(result);
      } catch (error) {
        logger.error(`Error executing tool ${req.params.toolName}:`, error);
        res.status(500).json({ error: `Failed to execute tool: ${error}` });
      }
    });

    // List available prompts
    this.app.get('/prompts', async (req, res) => {
      try {
        const prompts = await this.mcpServer.getServer().request(
          { method: 'prompts/list' },
          {}
        );
        res.json(prompts);
      } catch (error) {
        logger.error('Error listing prompts:', error);
        res.status(500).json({ error: 'Failed to list prompts' });
      }
    });

    // Get specific prompt
    this.app.get('/prompts/:promptName', async (req, res) => {
      try {
        const { promptName } = req.params;
        const prompt = await this.mcpServer.getServer().request(
          {
            method: 'prompts/get',
            params: { name: promptName }
          },
          {}
        );
        res.json(prompt);
      } catch (error) {
        logger.error(`Error getting prompt ${req.params.promptName}:`, error);
        res.status(500).json({ error: `Failed to get prompt: ${error}` });
      }
    });

    // List resources
    this.app.get('/resources', async (req, res) => {
      try {
        const resources = await this.mcpServer.getServer().request(
          { method: 'resources/list' },
          {}
        );
        res.json(resources);
      } catch (error) {
        logger.error('Error listing resources:', error);
        res.status(500).json({ error: 'Failed to list resources' });
      }
    });

    // Get specific resource
    this.app.get('/resources/*', async (req, res) => {
      try {
        const uri = req.path.replace('/resources/', '');
        const resource = await this.mcpServer.getServer().request(
          {
            method: 'resources/read',
            params: { uri: decodeURIComponent(uri) }
          },
          {}
        );
        res.json(resource);
      } catch (error) {
        logger.error(`Error getting resource ${req.path}:`, error);
        res.status(500).json({ error: `Failed to get resource: ${error}` });
      }
    });

    // 404 handler
    this.app.use((req, res) => {
      res.status(404).json({ error: 'Endpoint not found' });
    });
  }

  async start(): Promise<void> {
    try {
      // Initialize the MCP server first
      await this.mcpServer.initialize();

      // Start HTTP server
      this.app.listen(this.port, () => {
        logger.info(`AutoHotkey HTTP Server started on port ${this.port}`);
        logger.info(`Available endpoints:`);
        logger.info(`  GET  /health - Health check`);
        logger.info(`  GET  /tools - List available tools`);
        logger.info(`  POST /tools/:toolName - Execute a tool`);
        logger.info(`  GET  /prompts - List available prompts`);
        logger.info(`  GET  /prompts/:promptName - Get a prompt`);
        logger.info(`  GET  /resources - List available resources`);
        logger.info(`  GET  /resources/* - Get a resource`);
      });

    } catch (error) {
      logger.error('Failed to start AutoHotkey HTTP Server:', error);
      process.exit(1);
    }
  }
}

// Start the server if run directly
if (import.meta.url === `file://${process.argv[1]}`) {
  const port = process.env.PORT ? parseInt(process.env.PORT) : 3000;
  const server = new AutoHotkeyHttpServer(port);
  server.start();
}

export { AutoHotkeyHttpServer };