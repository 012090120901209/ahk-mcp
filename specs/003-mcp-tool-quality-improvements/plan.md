# Implementation Plan: MCP Tool Quality Improvements

**Branch**: `003-mcp-tool-quality-improvements` | **Date**: 2025-10-03 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/003-mcp-tool-quality-improvements/spec.md`

## Execution Flow (/plan command scope)
```
1. Load feature spec from Input path ✅
2. Fill Technical Context ✅
   → Project Type: MCP Server (Node.js)
   → Structure Decision: Single project
3. Constitution Check: N/A (quality improvements to existing code)
4. Execute Phase 0 → research.md
5. Execute Phase 1 → contracts, quickstart.md, CLAUDE.md
6. Re-evaluate Constitution Check (N/A)
7. Plan Phase 2 → Task generation approach
8. STOP - Ready for /tasks command
```

## Summary
Improve developer experience for MCP tool consumers by:
1. Renaming ambiguous parameter `content` → `newContent` (backward compatible)
2. Adding `debugMode` flag for orchestration transparency
3. Adding `dryRun` flag for safe preview of destructive operations
4. Enriching tool descriptions with concrete usage examples

**Technical Approach**: Extend existing Zod schemas with new optional parameters, maintain backward compatibility via parameter aliases, format output with clear visual markers for debug/dry-run modes.

## Technical Context
**Language/Version**: TypeScript 5.x, Node.js 18+
**Primary Dependencies**: Zod (validation), @modelcontextprotocol/sdk
**Storage**: N/A (tool improvements only)
**Testing**: Jest or native Node test runner
**Target Platform**: Node.js MCP servers (stdio transport)
**Project Type**: single (existing MCP server)
**Performance Goals**:
  - Debug overhead: <10ms per operation
  - Dry-run preview: <100ms for 10K line files
  - Schema validation: <5ms per call
**Constraints**:
  - MUST maintain backward compatibility with existing tool consumers
  - Parameter aliases MUST work transparently (no breaking changes)
  - Output format MUST remain machine-parseable (JSON structure preserved)
**Scale/Scope**:
  - ~8 tools to update (AHK_File_Edit, AHK_Smart_Orchestrator, etc.)
  - ~50 existing tool integrations to remain compatible

## Constitution Check
*GATE: N/A - This feature improves existing functionality without introducing new architectural complexity*

**Rationale**: Quality improvements to existing tools don't violate simplicity, testing, or library-first principles. Changes are additive (new optional parameters) and maintain existing contracts.

## Project Structure

### Documentation (this feature)
```
specs/003-mcp-tool-quality-improvements/
├── plan.md              # This file
├── research.md          # Phase 0: Parameter naming patterns, debug format standards
├── quickstart.md        # Phase 1: Testing scenarios for each improvement
├── contracts/           # Phase 1: Updated tool schemas
│   ├── edit-tool-schema.json       # AHK_File_Edit with newContent + dryRun
│   ├── orchestrator-schema.json    # AHK_Smart_Orchestrator with debugMode
│   └── enhanced-descriptions.json  # Tool description examples
└── tasks.md             # Phase 2: Generated by /tasks command
```

### Source Code (repository root)
```
src/
├── tools/
│   ├── ahk-file-edit.ts              # Add newContent alias, dryRun logic
│   ├── ahk-file-edit-advanced.ts     # Add newContent alias, dryRun logic
│   ├── ahk-file-edit-small.ts        # Add newContent alias, dryRun logic
│   ├── ahk-file-edit-diff.ts         # Add dryRun preview
│   └── ahk-smart-orchestrator.ts     # Add debugMode, enhanced logging
├── core/
│   ├── orchestration-engine.ts       # Debug output formatting
│   ├── tool-settings.ts              # Global debug/dryRun defaults
│   └── parameter-aliases.ts          # NEW: Parameter backward compat layer
└── utils/
    ├── debug-formatter.ts            # NEW: Format debug logs with markers
    └── dry-run-preview.ts            # NEW: Generate change previews

tests/
├── unit/
│   ├── parameter-aliases.test.ts     # Test content → newContent mapping
│   ├── debug-formatter.test.ts       # Test debug output format
│   └── dry-run-preview.test.ts       # Test preview generation
├── integration/
│   ├── edit-dryrun.test.ts           # End-to-end dry-run workflow
│   ├── orchestrator-debug.test.ts    # Debug mode integration
│   └── backward-compat.test.ts       # Old parameter names still work
└── contract/
    └── tool-schemas.test.ts          # Validate JSON schema updates
```

**Structure Decision**: Single project structure maintained. New utility modules added under `src/utils/` for debug formatting and dry-run logic. Existing tool files modified in-place with backward-compatible schema extensions.

## Phase 0: Outline & Research

### Research Tasks

#### R1: Parameter Naming Patterns
**Task**: Research best practices for API parameter naming in developer tools
**Questions**:
- Industry standards for "new/replacement content" parameters?
- How do other code editors/IDEs name similar parameters?
- Common patterns: `newContent`, `replacement`, `value`, `text`?

**Output**: Recommendation for parameter name + rationale

#### R2: Debug Output Standards
**Task**: Research debug output formatting in CLI/SDK tools
**Questions**:
- Standard markers for debug vs normal output? (🔍, [DEBUG], etc.)
- Structured vs inline debug info?
- Truncation strategies for verbose debug output?

**References**:
- Terraform plan/apply output
- Docker build output with --progress
- AWS CLI --debug flag

**Output**: Debug format specification

#### R3: Dry-Run Patterns
**Task**: Research dry-run/preview implementations in similar tools
**Questions**:
- Diff format standards (unified diff, side-by-side)?
- How many examples to show? (Git shows first 3 changed files by default)
- Summary format: counts, file lists, warnings?

**References**:
- Git `--dry-run` flag
- Terraform `plan` command
- Ansible `--check` mode

**Output**: Dry-run preview format specification

#### R4: Backward Compatibility Strategies
**Task**: Research parameter aliasing/deprecation in Zod schemas
**Questions**:
- Can Zod schemas have aliased field names?
- How to show deprecation warnings without breaking?
- Migration path for consumers?

**Output**: Implementation strategy for parameter aliases

**Consolidated Output**: `research.md` with decisions, rationales, and code examples

## Phase 1: Design & Contracts

### 1. Data Models (`data-model.md`)

**ToolParameter Model**:
```typescript
{
  name: string            // Primary name (e.g., "newContent")
  aliases: string[]       // Backward compat (e.g., ["content"])
  type: ZodType          // Validation schema
  description: string    // With inline example
  deprecated: boolean    // Mark old names
  examples: string[]     // 2-3 usage examples
}
```

**DebugOutput Model**:
```typescript
{
  enabled: boolean
  timestamp: number
  entries: Array<{
    tool: string         // Tool name called
    reason: string       // Why it was called
    duration: number     // Execution time
    cacheStatus: 'HIT' | 'MISS' | 'N/A'
  }>
  truncated: boolean     // If output was limited
}
```

**DryRunPreview Model**:
```typescript
{
  mode: 'dryRun'
  summary: {
    filesAffected: number
    totalChanges: number
    operationType: 'replace' | 'insert' | 'delete'
  }
  samples: Array<{
    file: string
    lineStart: number
    before: string
    after: string
  }>
  warnings: string[]     // Potential issues
}
```

### 2. API Contracts (`/contracts/`)

#### Contract 1: Enhanced Edit Tool Schema
**File**: `contracts/edit-tool-schema.json`

```json
{
  "name": "AHK_File_Edit",
  "inputSchema": {
    "type": "object",
    "properties": {
      "action": { "type": "string", "enum": ["replace", "insert", "delete"] },
      "search": { "type": "string" },
      "newContent": {
        "type": "string",
        "description": "Text to insert/replace. Example: 'class MyClass { ... }'",
        "examples": ["New text here", "function foo() { return 42; }"]
      },
      "content": {
        "type": "string",
        "deprecated": true,
        "description": "DEPRECATED: Use 'newContent' instead. Alias maintained for compatibility."
      },
      "dryRun": {
        "type": "boolean",
        "default": false,
        "description": "Preview changes without modifying files"
      }
    }
  }
}
```

#### Contract 2: Orchestrator Debug Mode Schema
**File**: `contracts/orchestrator-schema.json`

```json
{
  "name": "AHK_Smart_Orchestrator",
  "inputSchema": {
    "properties": {
      "debugMode": {
        "type": "boolean",
        "default": false,
        "description": "Show orchestration decision log"
      }
    }
  },
  "outputFormat": {
    "normal": {
      "content": [{ "type": "text", "text": "..." }]
    },
    "withDebug": {
      "content": [
        { "type": "text", "text": "..." },
        { "type": "text", "text": "🔍 DEBUG: ..." }
      ]
    }
  }
}
```

### 3. Contract Tests

#### Test: Parameter Alias Compatibility
```typescript
// tests/contract/parameter-aliases.test.ts
describe('AHK_File_Edit backward compatibility', () => {
  it('should accept deprecated "content" parameter', async () => {
    const result = await editTool.execute({
      action: 'replace',
      search: 'old',
      content: 'new'  // Old parameter name
    });
    expect(result.isError).toBe(false);
  });

  it('should prefer "newContent" over "content" when both provided', async () => {
    const result = await editTool.execute({
      action: 'replace',
      search: 'old',
      content: 'wrong',
      newContent: 'correct'
    });
    expect(result.content[0].text).toContain('correct');
  });
});
```

#### Test: Dry-Run Preview Format
```typescript
// tests/contract/dry-run-output.test.ts
describe('Dry-run preview format', () => {
  it('should show summary and samples without modifying file', async () => {
    const result = await editTool.execute({
      action: 'replace',
      search: 'foo',
      newContent: 'bar',
      all: true,
      dryRun: true
    });

    expect(result.content[0].text).toMatch(/DRY RUN/);
    expect(result.content[0].text).toMatch(/Would replace \d+ occurrences/);
    expect(result.content[0].text).toMatch(/No changes made/);
  });
});
```

#### Test: Debug Output Structure
```typescript
// tests/contract/debug-output.test.ts
describe('Debug mode output', () => {
  it('should include orchestration decisions when debugMode=true', async () => {
    const result = await orchestrator.execute({
      intent: 'edit class',
      debugMode: true
    });

    expect(result.content.some(c => c.text.includes('🔍 DEBUG:'))).toBe(true);
    expect(result.content.some(c => c.text.match(/Tool: AHK_Analyze.*Reason:/))).toBe(true);
  });

  it('should not include debug output when debugMode=false', async () => {
    const result = await orchestrator.execute({
      intent: 'edit class',
      debugMode: false
    });

    expect(result.content.every(c => !c.text.includes('🔍 DEBUG:'))).toBe(true);
  });
});
```

### 4. Quickstart Scenarios (`quickstart.md`)

See separate quickstart.md file for:
- Scenario 1: Using newContent parameter
- Scenario 2: Enabling debug mode
- Scenario 3: Dry-run preview
- Scenario 4: Reading enhanced tool descriptions

### 5. Agent Context Update

Run update script:
```bash
.specify/scripts/bash/update-agent-context.sh claude
```

**New context to add**:
- Parameter naming: Use `newContent` for replacement text (backward compat with `content`)
- Debug mode: Set `debugMode: true` for orchestration visibility
- Dry-run: Set `dryRun: true` to preview destructive operations
- Tool descriptions now include usage examples

## Phase 2: Task Planning Approach
*This section describes what the /tasks command will do*

**Task Generation Strategy**:
1. Load contracts from Phase 1
2. For each contract → create contract test task [P]
3. For each schema change → create migration task
4. For each new utility (debug formatter, dry-run) → create implementation task [P]
5. For each tool to update → create update task (8 tools total)
6. Integration tests for workflows
7. Documentation updates

**Ordering Strategy**:
1. Contract tests (fail initially) [P]
2. Utility implementations (parameter aliases, debug formatter, dry-run preview) [P]
3. Tool updates (AHK_File_Edit, AHK_Smart_Orchestrator, etc.)
4. Integration tests
5. Documentation (CLAUDE.md, tool descriptions)

**Estimated Output**: 20-25 tasks in dependency order

## Phase 3+: Future Implementation
*Beyond /plan scope*

**Phase 3**: Task execution via /tasks command
**Phase 4**: Implementation following TDD cycle
**Phase 5**: Validation with quickstart scenarios

## Complexity Tracking
*No constitutional violations identified*

This feature improves existing functionality through:
- Additive changes (new optional parameters)
- Backward-compatible schema updates
- Enhanced usability without new architecture

## Progress Tracking

**Phase Status**:
- [x] Phase 0: Research complete (needs execution)
- [ ] Phase 1: Design complete (needs execution)
- [ ] Phase 2: Task planning described
- [ ] Phase 3: Tasks generated (/tasks command)
- [ ] Phase 4: Implementation complete
- [ ] Phase 5: Validation passed

**Gate Status**:
- [x] Initial Constitution Check: N/A (quality improvements)
- [ ] Post-Design Constitution Check: N/A
- [x] All NEEDS CLARIFICATION resolved (debug logs capped at 5,000 chars; dry-run shows 3 samples)
- [x] Complexity deviations documented: None

**Resolved Items**:
- [x] Debug output truncation limit confirmed at 5,000 characters (configurable)
- [x] Dry-run preview shows the first 3 before/after examples by default

---
*Based on Constitution v2.1.1 - See `/memory/constitution.md`*
